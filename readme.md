# dj_example
主要包含的也是两部分 django & gulp

## django
简单的空白后端
*  django的starter，没有任何实际内容
*  写了一些基本功能
*  简单扩展了django admin
*  集成 django restful api
*  简单用户相关限定只读API
*  ......

## gulp
简单的前端自动化流程

适合中小型项目

只是挑选了必要的处理

## 目的

开发这个项目实际上是为了找到一个适合(至少适合我自己当前状况)的前端自动化流程

最近有了一小段空闲(1周内没有deadline ^_^)所以考虑了一下做了这个小demo

不好意思的说一下，在这之前的公司项目，前端都是意大利面的，正好进入下一个阶段，感觉这个阶段要把前端基本的事情都要处理好

## 碰到的问题

* 缓存(功能更新了，你们清一下缓存)
* 维护(等一下啊，我找找这个功能代码在哪)

实际上也就是网络巨头们在好些好些年前就已经解决的问题

但是很多的团队至今仍然在做着最原始的前端开发，比如我的团队

* 产品：我
* 设计：我
* 前端：我
* 后端：我
* 运维：我
* 客服：我

## 更深层次的问题

其实我的团队的整体技术水平还是很不错的

比如

* 产品会写js, python，java，php，C++

* 前端会配置apache，mysql，mongodb，firewall , redis , 会crond啊，生成个二维码啊什么的。

* 后端也能写html，css

好了不开玩笑了 ^_^ 反正都是我

其实我在做这个demo之前就问我自己，为什么之前的项目不做前端工程化呢

好多人可能会认为，没技术啊，有技术也没时间啊，人太少啊有必要吗

我认为是什么时间"合适"开始考虑工程化

* 下周要上线
* 这个重要，插进来做一下
* 帮我查一下数据，好像有错

其实 没技术没时间没人都只是表像，真说出来也只是借口

如果要让我自己找借口为什么不做工程化，我更倾向于具体项目，具体阶段是否合适

并不是所有项目都必须做前端工程化的，比如说我当前公司外包的公司主页就啥都没有，只有一个index.html而已

不是所有项目已开始就要考虑工程化的，比如说我正在进行中的项目，在正式内部测试之前，我都没有考虑过任何工程化或者优化，因为老板有空就过来问我，啥时候能用新系统啊，啥时候能做完功能啊，啥时候能吧UI做漂亮点啊。所以在这些"紧急而且重要"的任务之前，不适合考虑工程化或者优化。在我的认识中，前端工程化属于"重要的任务"，但不紧急。

那么什么时候合适，做到什么程度，个人认为，当你感觉到"需要"工程化的时候，就该开始做了，比如说我现在，感觉需要工程化一下当前项目的前端，那么现在就是合适的时候。
(核心功能开发完，测试基本完成，项目要正式上线了，将来要持续更新功能了，时间相对宽松了。)

#### 我当前的状况是这样的

* 非IT公司(我就是打杂的)
* 技术力量薄弱(就我一个打杂的)
* 开发全公司员工用的业务相关的系统(所以说fullstack就是打杂的)
* 持续开发新功能(我要，我们要，我们还要)
* 定死的限期deadline(你已经死了)

老板不管我用什么技术，他不懂，他只要限期内拿到结果。这事我最重要最紧急的任务。
任何有关业务的必要功能，尤其是相关客户的功能，都是紧急的任务。
这些都排在前端工程化之前。
这也是我和几年前的我的认识的区别。几年前的我会把我的最大需求排在前边的位置，现在我要把需要我的人们的需求排在最前。

## skill set

* html,css
* js,node,gulp
* python,django

这个demo中需要的就这些，挺简单的

就当作一个纯前端的项目也可以，甚至html，css也可以忽略，反正本项目没实际内容，主要是谈gulp自动构建

当然也可以吧第三条忽略掉，后端可以换用任何，本demo开始设计也是以前后分离为基础思想的，至少gulp部分没有碰触任何跟后端有关的东西。

可能在具体处理后端模版(如果有的话)的时候，要具体项目做具体细微的调整。

## 取舍

* 无css预处理，之后需要时再加入构建流程

	本人不会css，所以本次不加入less，sass或者postcss等


* gulp not grunt

	之前用过grunt，所以这次用gulp，看网上介绍gulp效率比grunt高，

* 不限定前端框架，在具体项目开发时选取

	没有选择前端框架，所以你可以自由选用喜欢的前端框架 angular1,angular2,angular4...angularX,angularForever, react, vue等


* 不按需加载，资源分级别打包

	不做打包优化按需加载，因为不是大型项目，不为了大流量访问极限优化，只做简单的合并压缩

	页面加载的资源(css,js)简单分为3个级别，vendor/app/page 分别为项目外引用，项目内公共功能，页面单独功能

* 也许仍旧含有大量es5，根据具体项目以及团队决定

	不一定使用es6,es7,也许继续用es5,或者混合使用

# 中小型前端构建思路

## 中小型项目包括什么

这里指的中小型包括什么呢 例如

* 个人blog
* 公司主页
* 招聘页面
* hr系统
* 客户管理
* ...

等等你可以想到的功能相对单一简单的，都可以称之为中小型，有一定的生命周期，不一定很长，但也不是很短比如至少要用个1-5年这样的。

一些临时的项目，例如做一个活动页面可以不算在内，不一定需要考虑这么多，也许单纯的用jquery写点意大利面就可以了。

你的老板更希望你3天上线一个1秒钟可以打开的活动页面，而不是半个月上线一个0.1秒就可以打开，可更新，易维护，高大上的，但是看起来一样的活动页面，因为半个月后已经是圣诞节而不是双12了。

## 中小型项目前端工程一些必要的处理

都是老生常谈了，google前端工程会给你很丰富的搜索结果。

但是这里还是要谈"合适"。

对于需要持续更新维护的中小型项目，在合适的阶段开始，我认为有必要开始考虑以下需求：

* 静态资源缓存
* 静态资源合并压缩
* 模块化开发(这里可能有些不同的认识)
* 自动发布(个人感觉不必需)

## 模块化开发

* 模块化开发可以理解为相对于意大利面开发而言，我们有更好的文件组织结构合理，功能层面上代码模块化

	对于本项目,具体来说要做到

	* app.js是由合理的文件组织打包而成
	* app.js共用功能有相应文档可查
	* 相关page.js,page.html,page.css组织合理


* 也可以理解为，我们有更好的可以重复使用的页面元素

	由于这里不涉及具体内容，不限定使用的前端框架，所以这个demo只要第一项，页面元素复用需要根据具体技术选择而定

## 前端工程化目的

* 流程自动化，以便更多关注在开发上
* 开发符合规范，易扩展，易维护
* 易读，加入项目开发门槛低

## 核心工具

* del 清理文件夹
* gulp 自动化任务
* gulp-concat 合并
* gulp-html-minify 压缩html
* gulp-minify-css 压缩css
* gulp-uglify 压缩js
* gulp-jshint js检查
* gulp-rev 资源名加MD5
* gulp-rev-collector 替换资源引用
* gulp-apidoc api文档

## 核心思想

* 静态资源压缩
* 静态资源非覆盖更新(加md5)
* css,js资源分级别打包合并
* html压缩

## 核心流程

主要注意资源合并替换顺序，根据一般情形，主要是css引用图片，html引用css，js，按照一般情形有如下流程

* 合并vendor资源 -> vendor.css,vendor.js
* 合并app资源 -> app.css,app.js
* 压缩所有css,js -> *.min.css,*.min.js
* md5所有img,js -> *.min.md5.js,*.md5.png[jpg...]
* 替换css中引用 -> *.min.css
* md5所有css -> *.min.md5.css
* 替换所有html中引用 -> *.html
* 压缩所有html -> *.html

### 未考虑前端模版循环引用

如果使用了前端模版
例如angular，并且使用angular-router，做SPA（单页应用），会存在js中加载html的情形
这里可以考虑做适当的区分，例如index.html是可以最后collect资源替换的，而页面html本身不含有js的情形可以去除循环引用
可以考虑如下流程build
* 合并vendor资源 -> vendor.css,vendor.js
* 合并app资源 -> app.css,app.js
* **压缩页面html -> template/*.html**
* 压缩所有css,js -> *.min.css, *.min.js
* **md5页面html -> template/*.md5.html**
* **替换js中页面html -> \*.min.js**
* md5所有img,js -> *.min.md5.js, *.md5.png[jpg...]
* 替换css中引用 -> *.min.css
* md5所有css -> *.min.md5.css
* 替换所有html中引用 -> *.html
* 压缩**index.html -> index.html**  
这样的顺序
